/*
 * Copyright (c) 20014-15 Arizona State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Abhishek Rhisheekesan
 *
 *	    Compiler and Microarchitecture Lab, ASU
 * 	    http://aviral.lab.asu.edu
 */

/** @file
 * Declaration of Vulnerability Interval objects.
 */

#ifndef __VULNERABILITY_TRACKER_HH__
#define __VULNERABILITY_TRACKER_HH__

#include <list>
#include <map>
#include <numeric>
#include <fstream>
#include <iostream>
#include <string>

#include "base/types.hh"
#include "base/vulnerability/access_tracker.hh"
#include "base/vulnerability/vulnerability_interval.hh"
#include "base/trace.hh"//abhi
#include "base/debug.hh"//abhi
#include "debug/BaseVulnerability.hh"//abhi

using namespace std;

class VulnerabilityTracker
{
  public:
    ////Variable type of vulnerability tracker ID
    //typedef unsigned int VulTrackerIDType;

    //Variable type of vulnerability (ticks * bits)
    typedef VulnerabilityInterval::VulnerabilityType VulnerabilityType;

    //Variable type of list of vulne0rability intervals
    typedef std::list<VulnerabilityInterval*> VulnerabilityIntervalListType;
    //Variable type of iterator for list of vulnerability intervals
    typedef VulnerabilityIntervalListType::iterator VIlistIterator;

    //Variable type of list of access trackers
    typedef std::list<AccessTracker*> AccessTrackerListType;
    //Variable type of iterator for list of access trackers
    typedef AccessTrackerListType::iterator ATlistIterator;

    //Variable type for list of ATlistIterator pointers
    //typedef std::list<ATlistIterator*> ATlistIteratorListType;
    typedef std::list<ATlistIterator> ATlistIteratorListType;
    //Variable type of iterator for list of ATlistIterator
    typedef ATlistIteratorListType::iterator ATlistIteratorListIterator;
    //Variable type for map of access IDs to
    //a list of access tracker list iterator pointers
    typedef std::map< AccessTracker::AccessIDType, ATlistIteratorListType >
			ATAIDtoATlistIteratorListMapType;
    //Variable type of iterator for map of access IDs to
    //a list of access tracker list iterators
    typedef ATAIDtoATlistIteratorListMapType::iterator
			ATAIDtoATlistIteratorListMapIterator;

    //Variable type of list of access tracker IDs
    typedef std::list<AccessTracker::AccessIDType> AccessTrackerIDListType;
    //Variable type of iterator for list of access trackers
    typedef AccessTrackerIDListType::iterator ATIDlistIterator;

    //Variable type of map of access tracker IDs
    //(use during removal of accesses)
    //The key is access ID
    //Value is immaterial
    typedef std::map<AccessTracker::AccessIDType, bool> AccessTrackerIDMapType;
    //Variable type of iterator for map of access trackers
    typedef AccessTrackerIDListType::iterator ATIDmapIterator;
    
  private:
    //VulTrackerIDType vulTrackerID;//ID of vulnerability tracker

    //total vulnerability of the unit (in ticks * bits)
    VulnerabilityType totalVulnerability;

    //Start tick of the executable (program/benchmark) being run
    Tick executableStartTick;
    //End tick of the executable being run
    Tick executableEndTick;

    //flag to indicate to start tracking of vulnerabilitys
    bool hasStartedTrackingVulnerability;

    //Vulnerability tracking mode - file based
    //or access tracker class based (in short, memory based)
    //Dynamic calculates the vulnerabilities instantaneously
    //as instructions are committed/squashed
    unsigned int vulTrackingMode;

    //Module for which vulnerability is tracked
    //std::string vulModule;
    unsigned int vulModule;

    //List of vulnerability intervals associated with this unit
    VulnerabilityIntervalListType vulIntervalList;

    //List of accesses associated with this unit
    AccessTrackerListType accessList;

    //Maintain the iterator to access list
    ATlistIterator accessListIterator;

    //A map of access IDs to a list of access tracker list iterators
    ATAIDtoATlistIteratorListMapType aidToATlistIteratorListMap;

    //List of IDs of removed accesses associated with this unit
    //For eg: If an instruction is squashed,
    //the accesses associated with the instruction
    //might have to be removed.
    AccessTrackerIDListType removedAccessIDList;
    //Map of IDs of removed accesses associated with this unit
    AccessTrackerIDMapType removedAccessIDMap;

    //Files to track read/write accesses and removed access IDs
    std::fstream accessTrackerFile;
    
    //std::ofstream vulf_out;
    
    //std::fstream removeAccessIDfile;

    //Vulnerability tracking mode - file based
    //or access tracker class based (in short, memory based)
    //Dynamic calculates the vulnerabilities instantaneously
    //as instructions are committed/squashed
    enum{
      File,
      Memory,
      Dynamic,
      DUMMY_MAX_VTM
    };

    /** Dynamic vulnerability tracking mode variables */
    //whether to commit or remove the access in dynamic mode
    enum{
      DynamicCommit,
      DynamicRemove
    };

    //recent non-committed write access tick
    Tick recentNonCommitWriteTick;

    //number of vulnerability bits in
    //recent non-committed write access
    unsigned int recentNonCommitWriteNumBits;

    //recent non-committed vulnerability interval
    VulnerabilityType recentNonCommitVulInterval;

    //To identify previous access mode
    AccessTracker::AccessModeType previousAccessMode;

    //set the executable's end tick
    void setExecutableEndTick(Tick eet)
    {
      assert(executableEndTick >= 0 &&
	     "Executable end tick is negative");
      executableEndTick = eet;
    }

  public:
    ////Usual constructor
    //VulnerabilityTracker(VulTrackerIDType vtid, Tick est,
    //    		 bool stv, unsigned int vtm)
    //    : vulTrackerID(vtid), executableStartTick(est),
    //    	hasStartedTrackingVulnerability(stv),
    //    	vulTrackingMode(vtm)
    //{
    //  assert(executableStartTick >= 0 &&
    //         "Ctor1: Executable start tick is negative");
    //  totalVulnerability = 0;
    //  assert(vulTrackingMode < DUMMY_MAX_VTM &&
    //    "Ctor1: Trying to initialize invalid Vulnerability Tracking Mode");
    //  if(vulTrackingMode == Dynamic)
    //  {
    //    recentNonCommitVulInterval = 0;
    //    recentNonCommitWriteNumBits = 0;
    //    previousAccessMode = AccessTracker::DUMMYMAX;
    //  }
    //}

    //Usual constructor with module name
    //Module name is used to maintain unique filenames
    //for access tracking and removal of access IDs
    VulnerabilityTracker(Tick est, bool stv, unsigned int vtm,
		unsigned int module)
		//std::string module)
		//const std::string& module)
	: executableStartTick(est),
	  hasStartedTrackingVulnerability(stv),
	  vulTrackingMode(vtm), vulModule(module)
    {
      assert(executableStartTick >= 0 &&
	     "Ctor2: Executable start tick is negative");
      totalVulnerability = 0;
      assert(vulTrackingMode < DUMMY_MAX_VTM &&
	"Ctor2: Trying to initialize invalid Vulnerability Tracking Mode");
      

      //vulModule = module;

      //if(vulTrackingMode == File)
      //{
      //  std::string atFileName = vulModule + "_access_tracker.txt";
      //  //std::string raidFileName = vulModule + "_remove_access_id.txt";
      //  //accessTrackerFile.open(atFileName,std::ios::in|std::ios::out);
      //  accessTrackerFile.open(atFileName,
      //    std::fstream::in|std::fstream::out|std::fstream::app);
      //  if(!accessTrackerFile.is_open())
      //  {
      //    DPRINTF(BaseVulnerability,
      //    	"Ctor2: Cannot open the file to track accesses");
      //  }
      //  //removeAccessIDfile.open(raidFileName,ios::in|ios::out);
      //  assert(accessTrackerFile.is_open() &&
      //    	"Ctor2: Cannot open file to track accesses");
      //}
      //else if(vulTrackingMode == Dynamic)
      //{
      //  recentNonCommitVulInterval = 0;
      //  recentNonCommitWriteNumBits = 0;
      //  previousAccessMode = AccessTracker::DUMMYMAX;
      //}
    }

    void startTrackingVulnerability(Tick est)
    {

      assert(est >= 0 &&
	     "Executable start tick intitalized is negative");
      hasStartedTrackingVulnerability = true;
      executableStartTick = est;

      if(vulTrackingMode == File)
      {  
        std::string atFileName = vulModule + "_access_tracker.txt";
        //std::string raidFileName = vulModule + "_remove_access_id.txt";
        //accessTrackerFile.open(atFileName,std::ios::in);
        accessTrackerFile.open(atFileName,
          std::fstream::in|std::fstream::out|std::fstream::trunc);
        if(!accessTrackerFile.is_open())
        {
          DPRINTF(BaseVulnerability,
          	"startTrackingVulnerability: "
		"Cannot open the file to track accesses");
        }
        //removeAccessIDfile.open(raidFileName,ios::in|ios::out);
        assert(accessTrackerFile.is_open() &&
          	"startTrackingVulnerability: "
		"Cannot open file to track accesses");
      }
      else if(vulTrackingMode == Dynamic)
      {
	/*char c[100];
         sprintf(c,"vulReport_%d.csv",vulModule);
         vulf_out.open(c, ios::out);*/
        /* vulf_out<< "Time,SeqNum,Interval,Bits"
                 << endl;*/
         //vulf_out << "Time,Bits"<<endl;
        recentNonCommitVulInterval = 0;
	recentNonCommitWriteNumBits = 0;
        previousAccessMode = AccessTracker::DUMMYMAX;
      }
        
    }

    void setVulnerabilityTrackingMode(unsigned int vtm)
    {
      assert(vtm < DUMMY_MAX_VTM &&
	"Trying to initialize invalid Vulnerability Tracking Mode");
      vulTrackingMode = vtm;
    }

    //register this access to the unit
    //Provide access ID, mode (read/write),
    //the number of accessed bits,
    //and the tick of access as inputs
    void registerAccess(AccessTracker::AccessIDType aid,
			AccessTracker::AccessModeType am,
			unsigned int nb, Tick at)
    {
      if(hasStartedTrackingVulnerability)
      {
	if(vulTrackingMode == Memory ||
	   vulTrackingMode == Dynamic)
	{
	  //DEBUG
	  //if(((vulModule >= 1000) && (vulModule < 2048))
	  //       || ((vulModule >= 11000) && (vulModule < 12048)))
	  //{
	  //  DPRINTF(BaseVulnerability,"VulTrackerModule:%i:registerAccess:"
	  //  //DPRINTF(BaseVulnerability,"VulTrackerModule:%s:registerAccess:"
	  //        "accessList:Size:%i:accessID:%lli:AccessMode:%i:"
	  //        "Number of bits:%i:Access tick:%lli\n",
	  //  	vulModule, accessList.size(), aid, am, nb, at);
	  //  	//vulModule.c_str(), accessList.size(), aid, am, nb, at);
	  //}

          //flag to indicate if access list is empty or not
          bool isAccessListEmpty = false;
	  if(accessList.empty())
            isAccessListEmpty = true;

	  //insert the entry in access list
          AccessTracker *actr = new AccessTracker(aid,am,nb,at);
          accessList.push_back(actr);
	//  DPRINTF(BaseVulnerability,"registerAccess:"
	//	"AccessTracker pointer:%x\n",actr);

	  if(isAccessListEmpty)//was it empty before this insert
	  {
	    accessListIterator = accessList.begin();
	  }
	  else
	  {
	    accessListIterator++;
	  }
	//  DPRINTF(BaseVulnerability,"registerAccess:accessListIterator:%x\n",
	//			&(*accessListIterator));
	  //DPRINTF(BaseVulnerability,"Registering access : "
	  //	"accessListIterator : %x : access ID : %i\n",
	  //	&accessListIterator,aid);

	  //Maintain a map of access IDs to the access list iterators
	  //for easy removal later
	  //Check if the entry corresponding to this access ID
	  //exists in the map
	  ATAIDtoATlistIteratorListMapIterator aidatlilmit
	  	= aidToATlistIteratorListMap.find(aid);
	  if(aidatlilmit != aidToATlistIteratorListMap.end())
	  {
	    //Add the access tracker list iterator
	    //to the exisitng list in the map
	    (aidatlilmit->second).push_back(accessListIterator);
	  }
	  else//insert this access ID to iterator mapping entry in the map
	  {
	    ATlistIteratorListType atListItList;

	    atListItList.push_back(accessListIterator);
	//    DPRINTF(BaseVulnerability,"registerAccess:"
	//	"atListItList:%x\n",&atListItList);

	    //insert this list into the map
	    aidToATlistIteratorListMap.insert(make_pair(aid,atListItList));
	  }

	  //DEBUG
	  //if(((vulModule >= 1000) && (vulModule < 2048))
	  //       || ((vulModule >= 11000) && (vulModule < 12048)))
	  //{
	  //  //DEBUG
	  //  ATAIDtoATlistIteratorListMapIterator aidatlilmit1
	  //  	= aidToATlistIteratorListMap.find(aid);
	  ////  DPRINTF(BaseVulnerability,"registerAccess:"
	  ////	"aidToATlistIteratorListMap iterator:%x\n",&(*aidatlilmit1));
	  ////  DPRINTF(BaseVulnerability,"registerAccess:"
	  ////	"aidatlilmit1->second addr:%x\n",&(aidatlilmit1->second));

	  //  DPRINTF(BaseVulnerability,"registerAccess:"
	  //	"aidatlilmit1->second list size:%i\n",
	  //	(aidatlilmit1->second).size());
	  //}
	}//end of if(vulTrackingMode == Memory)
	else if(vulTrackingMode == File)
	{
	  accessTrackerFile << aid << " " << am << " "
			    << nb << " " << at << "\n";
	}//end of else if(vulTrackingMode == File)

      }//end of if(hasStartedTrackingVulnerability)
    }

    //Remove the accesses associated with this access ID
    //In Dynamic mode, commitOrRemove implies whether to
    //remove the access from vulnerability tracker
    //or to commit it. Commiting means vulnerability
    //intervals associated with the committed accesses are
    //calculated.
    void removeAccess(AccessTracker::AccessIDType aid,
		unsigned int commitOrRemove)
    {
      if(hasStartedTrackingVulnerability)
      {
	if(vulTrackingMode == Memory ||
	   vulTrackingMode == Dynamic)
	{
	  //DPRINTF(BaseVulnerability,"VulTrackerModule:%i:removeAccess:"
	  ////DPRINTF(BaseVulnerability,"VulTrackerModule:%s:removeAccess:"
	  //      "accessList:Size:%i:accessID:%lli:commitOrRemove:%i\n",
	  //	vulModule, accessList.size(), aid, commitOrRemove);
	  //	//vulModule.c_str(), accessList.size(), aid, commitOrRemove);

	  //DEBUG
	  //if(((vulModule >= 1000) && (vulModule < 2048))
	  //       || ((vulModule >= 11000) && (vulModule < 12048)))
	  //{
	  //  DPRINTF(BaseVulnerability,"VulTrackerModule:%i:removeAccess:"
	  //        "accessList:Size:%i:accessID:%lli:commitOrRemove:%i\n",
	  //  	vulModule, accessList.size(), aid, commitOrRemove);

	  //  for(ATlistIterator atli = accessList.begin(),
	  //           		atle = accessList.end();
	  //           		atli != atle; atli++)
	  //  {
	  //      DPRINTF(BaseVulnerability,"VulTrackerModule:%i:"
	  //      "aid:%lli:am:%i:at:%lli\n",vulModule,
	  //      (*atli)->getAccessID(),(*atli)->getAccessMode(),
	  //      (*atli)->getAccessTick());
	  //  }
	  //}

	  //Check if the entry corresponding to this access ID
	  //exists in the map
	  ATAIDtoATlistIteratorListMapIterator aidatlilmit
	  	= aidToATlistIteratorListMap.find(aid);
	  if(aidatlilmit != aidToATlistIteratorListMap.end())
	  {
	    for(ATlistIteratorListIterator atlili
	  	 = (aidatlilmit->second).begin(),
	    	atlile = (aidatlilmit->second).end();
	  	atlili != atlile; atlili++)
            {
	      if(commitOrRemove == DynamicCommit)
	      {
	        //DPRINTF(BaseVulnerability,"Commiting access : "
	      	//  "accessListIterator : %x : access ID : %i\n",
	      	//  &(*atlili),aid);
                if((**atlili)->getAccessMode() == AccessTracker::WRITE)
                {
	       	  //if previous access mode is READ, commit
	          //the previous vulnerability interval
                  if(previousAccessMode == AccessTracker::READ)
                  {
                    //int i = 0;
                      
                    totalVulnerability
			 += (recentNonCommitVulInterval 
	        			* recentNonCommitWriteNumBits);
                    /*
		    //vulf_out<< recentNonCommitWriteTick << "," 
                    //        << aid << ","
                    //    << recentNonCommitVulInterval << "," 
                    //       << recentNonCommitWriteNumBits
                    //       << endl;
                     */
                   
                 /*   for (i = recentNonCommitWriteTick; 
                            i<(recentNonCommitWriteTick
                                +recentNonCommitVulInterval);i+=500)
                    {
                        vulf_out<< i << ","
                            << recentNonCommitWriteNumBits
                            << endl;
                    }
                    */
                  }

		  //update recent non-committed write access tick
		  //with the access tick of this access
		  recentNonCommitWriteTick = (**atlili)->getAccessTick();

		  //update the number of vulnerability bits in
		  //recent non-committed write access with number of bits
		  //in this access
		  recentNonCommitWriteNumBits = (**atlili)->getNumBits();
                }

                if((**atlili)->getAccessMode() == AccessTracker::READ)
                {
                  if(previousAccessMode == AccessTracker::DUMMYMAX)
                  {
                    //first access is a READ, so vulnerability starts at
                    //start of the program being run
		    //Update recent non-committed write access tick
		    //with the access tick of the start of the executable
		    recentNonCommitWriteTick = executableStartTick;

		    //update the number of vulnerability bits in
		    //recent non-committed write access with number of bits
		    //in this access
		    recentNonCommitWriteNumBits = (**atlili)->getNumBits();
                  }

	          //update the non committed vulnerability interval
	          //using the access tick of this access as
	          //the end of the vulnerability interval
		  recentNonCommitVulInterval
			 = (**atlili)->getAccessTick()
				 - recentNonCommitWriteTick;
                }

	        //update previous access mode with current access mode
	        previousAccessMode = (**atlili)->getAccessMode();

	      }//end of if(commitOrRemove == Commit)
	      else if(commitOrRemove == DynamicRemove)
	      {
	        //DPRINTF(BaseVulnerability,"Removing access : "
	    	//  "accessListIterator : %x : access ID : %i\n",
	    	//  &(*atlili),aid);
	      }

	//      DPRINTF(BaseVulnerability,"removeAccess:"
	//	"AccessTracker pointer:%x\n",**atlili);
	//      DPRINTF(BaseVulnerability,"removeAccess:"
	//			"accessListIterator:%x\n",
	//			&(**atlili));
      	      delete **atlili;

    	      if(accessListIterator == *atlili)
	      {
	        accessListIterator--;
	      }

              accessList.erase(*atlili);
            }
	//    DPRINTF(BaseVulnerability,"removeAccess:"
	//	"aidToATlistIteratorListMap iterator:%x\n",&(*aidatlilmit));
	//    DPRINTF(BaseVulnerability,"removeAccess:"
	//	"aidatlilmit->second addr:%x\n",&(aidatlilmit->second));

	    //DEBUG
	    //if(((vulModule >= 1000) && (vulModule < 2048))
	    //       || ((vulModule >= 11000) && (vulModule < 12048)))
	    //{
	    //  DPRINTF(BaseVulnerability,"removeAccess:"
	    //      "aidatlilmit->second list size:%i\n",
	    //      (aidatlilmit->second).size());
	    //}

	    (aidatlilmit->second).clear();//FIXME is this required?
	    aidToATlistIteratorListMap.erase(aidatlilmit);

	    //DEBUG
	    //if(((vulModule >= 1000) && (vulModule < 2048))
	    //       || ((vulModule >= 11000) && (vulModule < 12048)))
	    //{
	    //  DPRINTF(BaseVulnerability,"removeAccess:"
	    //      "aidToATlistIteratorListMap size:%i\n",
	    //      aidToATlistIteratorListMap.size());
	    //}
	  }
	}//end of if(vulTrackingMode == Memory)
	else if(vulTrackingMode == File)
	{
	  //removeAccessIDfile << aid << "\n";
	  //FIXME check if this map creates a memory bottleneck
          removedAccessIDMap.insert(std::make_pair(aid,true));
	}//end of else if(vulTrackingMode == File)

      }
    }

    //call this once before vulnerability calculation
    //to remove all the unwanted accesses
    //(the ones tracked in the removal access ID list)
    void removeUnwantedAccesses()
    {
      if(hasStartedTrackingVulnerability)
      {
        if(!removedAccessIDList.empty())
        {
          for(ATlistIterator ati = accessList.begin(),
                             ate = accessList.end(); ati != ate; )
          {
            bool atiRemoved = false;

            for(ATIDlistIterator atidi = removedAccessIDList.begin(),
            		     atide = removedAccessIDList.end();
            		     atidi != atide; atidi++)
            {
              if((*ati)->getAccessID() == *atidi)
              {
		delete *ati;

                ati = accessList.erase(ati);

                atiRemoved = true;

                break;
              }
            }

            if(!atiRemoved)
              ati++;
          }
        }
      }
    }

    //Build the list of vulnerability intervals
    //after removing unwanted accesses
    //Pass executable's end tick as input
    void buildVIsAfterRemoveUAs(Tick eet)
    {
      if(hasStartedTrackingVulnerability)
      {
        removeUnwantedAccesses();

        buildVulnerabilityIntervals(eet);
      }
    }

    //Build the list of vulnerability intervals
    //Pass executable's end tick as input
    //Return the total vulnerability if it is file based
    VulnerabilityType buildVulnerabilityIntervals(Tick eet)
    {

      if(hasStartedTrackingVulnerability)
      {
	if(vulTrackingMode == Memory)
	{
          VulnerabilityInterval *VI = NULL;

          setExecutableEndTick(eet);

          //To identify previous access mode
          AccessTracker::AccessModeType prevAccessMode
            = AccessTracker::DUMMYMAX;

          for(ATlistIterator ati = accessList.begin(),
                             ate = accessList.end(); ati != ate; ati++)
          {
            if((*ati)->getAccessMode() == AccessTracker::WRITE)
            {
              if(prevAccessMode == AccessTracker::READ)
              {
                vulIntervalList.push_back(VI);
              }

              //create a new vulnerability interval
              //starting with this WRITE
              VulnerabilityInterval *tempVI
                = new VulnerabilityInterval(0,(*ati)->getAccessTick(),
	  		(*ati)->getNumBits());

              VI = tempVI;
            }

            if((*ati)->getAccessMode() == AccessTracker::READ)
            {
              if(prevAccessMode == AccessTracker::DUMMYMAX)
              {
                //first access is a READ, so vulnerability starts at
                //start of the program being run
                VulnerabilityInterval *tempVI
                  = new VulnerabilityInterval(0,executableStartTick,
	  		(*ati)->getNumBits());

                VI = tempVI;
              }

	      //currently, set this access tick as the end of the interval
              VI->setEndIntervalTick((*ati)->getAccessTick());
            }

	    //update previous access mode with current access mode
	    //(to be used in the next loop iteration)
	    prevAccessMode = (*ati)->getAccessMode();
          }

          //register the vulnerability interval if last access is a READ
          if(prevAccessMode == AccessTracker::READ)
          {
            vulIntervalList.push_back(VI);
          }

	  return 0;
	}//end of if(vulTrackingMode == Memory)
	else if(vulTrackingMode == File)
	{
	  //Total vulnerability variable for internal calculations
	  VulnerabilityType totalVul = 0;

          VulnerabilityInterval *VI = NULL;

          setExecutableEndTick(eet);

          //To identify previous access mode
          AccessTracker::AccessModeType prevAccessMode
            = AccessTracker::DUMMYMAX;

	  //Temporary variables to read input from the file
	  std::string fileLine;
	  AccessTracker::AccessIDType accessID;//ID of the access
	  AccessTracker::AccessModeType accessMode;//(read or write)
	  unsigned int numBits;//number of vulnerability bits
	  Tick accessTick;//access tick time
	  //unsigned int iteration = 0;
	  while(!accessTrackerFile.eof())
          {
	    //read a line from the file
	    accessTrackerFile >> std::skipws >> accessID
			 >> accessMode >> numBits >> accessTick;

	    //check if this access is in the removal map
	    if(removedAccessIDMap.find(accessID)
		!= removedAccessIDMap.end())
	    {
              if(accessMode == AccessTracker::WRITE)
              {
                //register the previous vulnerability interval
                if(prevAccessMode == AccessTracker::READ)
                {
	          totalVul += VI->getVulnerability();
                }

                //create a new vulnerability interval
                //starting with this WRITE
                VulnerabilityInterval *tempVI
                  = new VulnerabilityInterval(0,accessTick,numBits);

                VI = tempVI;
              }

              if(accessMode == AccessTracker::READ)
              {
                if(prevAccessMode == AccessTracker::DUMMYMAX)
                {
                  //first access is a READ, so vulnerability starts at
                  //start of the program being run
                  VulnerabilityInterval *tempVI
                    = new VulnerabilityInterval(0,executableStartTick,numBits);

                  VI = tempVI;
                }

	        //currently, set this access tick as the end of the interval
                VI->setEndIntervalTick(accessTick);
              }

	      //update previous access mode with current access mode
	      //(to be used in the next loop iteration)
	      prevAccessMode = accessMode;
            }
          }

          //register the vulnerability interval if last access is a READ
          if(prevAccessMode == AccessTracker::READ)
          {
	    totalVul += VI->getVulnerability();
          }

	  return totalVul;
	}//end of else if(vulTrackingMode == File)

      }
      return 0;//indicate error - FIXME - with an error value
    }

    //Retrieve current vulnerability in case of Dynamic mode
    VulnerabilityType getCurrentVulnerability()
    {
      if(hasStartedTrackingVulnerability)
      {
	if(vulTrackingMode == Dynamic)
	{
	  return totalVulnerability;
    	}
      }
      return 0;
    }

    //calculate total vulnerability of the unit
    //Pass executable's end tick as input
    VulnerabilityType getTotalVulnerability(Tick eet)
    {
      if(hasStartedTrackingVulnerability)
      {
	if(vulTrackingMode == Memory)
	{
	  buildVulnerabilityIntervals(eet);

          //Accumulate the vulnerability values
          totalVulnerability = 0;

          for(VIlistIterator vii = vulIntervalList.begin(),
            		 vie = vulIntervalList.end();
            		 vii != vie; vii++)
          {
            totalVulnerability += (*vii)->getVulnerability();
          }

          assert(totalVulnerability >= 0 && "Total vulnerability is negative");
          return totalVulnerability;
	}//end of if(vulTrackingMode == Memory)
	else if(vulTrackingMode == File)
	{
	  //get the total vulnerability
	  totalVulnerability = buildVulnerabilityIntervals(eet);

          accessTrackerFile.close();//close the access tracker file

          return totalVulnerability;
	}//end of else if(vulTrackingMode == File)
	else if(vulTrackingMode == Dynamic)
	{
          //register the vulnerability interval if last access is a READ
          if(previousAccessMode == AccessTracker::READ)
          {
	    totalVulnerability
			 += (recentNonCommitVulInterval
				* recentNonCommitWriteNumBits);
          }

          return totalVulnerability;
	}//end of else if(vulTrackingMode == Dynamic)
      }

      return 0;//indicate error - FIXME - with an error value
    }
    
};

#endif // __VULNERABILITY_TRACKER_HH__
