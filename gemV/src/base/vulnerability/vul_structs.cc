/*
 * Copyright (c) 20014-15 Arizona State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Srinivas Tanikella
 *
 *	    Compiler and Microarchitecture Lab, ASU
 * 	    http://aviral.lab.asu.edu
 */

/*
void
QueueStruct::addField(InstField f, int size) {

    Field fd;

    fd.f = f;
    fd.size = size;
    fd.regIdx = -1;

    fields.push_back(fd);

}

void
QueueStruct::addRegField(InstField f, int size, int i) {

    Field fd;

    fd.f = f;
    fd.size = size;
    fd.regIdx = i;
    
    fields.push_back(fd);

}

void
QueueStruct::trackAccess(AccessType access, InstField f) {
    
    fIter fIt = fields.begin();

    while(fIt != fields.end()) {

        if(fIt->f == f) {
            DPRINTF(VulTracker, "QueueStruct::TrackAccess field found %d", fIt->f);
            break;
        }

        fIt++;
    }

    assert(fIt != fields.end());

    Access ac;

    ac.cycle = curTick()/TICKS_PER_CYCLE;
    ac.access = access;

    fIt->accesses.push_back(ac);

}

void
QueueStruct::trackRegAccess(AccessType access, InstField f, int idx) {
    
    fIter fIt = fields.begin();

    while(fIt != fields.end()) {

        if(fIt->f == f && fIt->regIdx == idx) {
            DPRINTF(VulTracker, "QueueStruct::TrackAccess field found %d", fIt->f);
            break;
        }

        fIt++;
    }

    assert(fIt != fields.end());

    Access ac;

    ac.cycle = curTick()/TICKS_PER_CYCLE;
    ac.access = access;

    fIt->accesses.push_back(ac);

}

void
QueueStruct::markAsWritten(InstField f) {
    
    fIter fIt = fields.begin();

    while(fIt != fields.end()) {

        if(fIt->f == f) {
            DPRINTF(VulTracker, "QueueStruct::markAsWritten field found %d", fIt->f);
            break;
        }

        fIt++;

    }

    fIt->accesses.back().isWritten = true;

}

bool
QueueStruct::markAsVulnerable(InstField f, int regIdx) {

    fIter fIt = fields.begin();

    while(fIt != fields.end()) {

        if(fIt->f == f) {
            if(f != INST_DESTREGSIDX && f != INST_SRCREGSIDX) {
                DPRINTF(VulTracker, "QueueStruct::markAsVulnerable field found %d", fIt->f);
                break;
            } else {
                if(fIt->regIdx == regIdx) {
                    DPRINTF(VulTracker, "QueueStruct::markAsVulnerable field found %d", fIt->f);
                    break;
                }
            }

        }

        fIt++;

    }
    
    fIt->accesses.back().isVulnerable = false;

    if(fIt->accesses.back().isWritten)
        return true;
    else
        return false;

}

long
QueueStruct::getVul() {
    
    long vul = 0;

    fIter fIt = fields.begin();

    while(fIt != fields.end()) {

        std::list<Access>::iterator aIt = fIt->accesses.begin();

        assert(aIt->access == INSERTFIELD); 

        long writeCycle = -1;   
                 
        while(aIt != fIt->accesses.end()) {

            if(aIt->access == INSERTFIELD)
                writeCycle = aIt->cycle;

            else {
                assert(writeCycle != -1);

                if(aIt->isVulnerable)
                    vul += (aIt->cycle - writeCycle)*fIt->size;
            }

            aIt++;            
               
        }

        fIt++;

    }

    return vul;
}
*/
