/*
 * Copyright (c) 20014-15 Arizona State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Srinivas Tanikella
 *
 *	    Compiler and Microarchitecture Lab, ASU
 * 	    http://aviral.lab.asu.edu
 */

#include "base/vulnerability/vul_tracker.hh"
#include "base/vulnerability/vul_structs.hh"
#include "debug/VulTracker.hh"

void
VulTracker::initVars(int numDest, int numSrc, int pcSize,
                            int numRegs) {
    
    addField(INST_OPCODE, OPCODE_WIDTH, "opcode");
    addField(INST_PC, pcSize, "pc");
    addField(INST_TID, 1, "tid");
    addField(INST_SEQNUM, SEQNUM_WIDTH,"seqnum");
    addField(INST_PREDPC, pcSize, "predpc");
    addField(INST_FLAGS, FLAGS_WIDTH, "flags");

    for(int i = 0; i < numSrc; ++i)
        addField(INST_RNMSRCREGSIDX, IDX_WIDTH,"rnmsrcregidx",i);

    for(int i = 0; i < numDest; ++i) {
        addField(INST_RNMDESTREGSIDX, IDX_WIDTH,"rnmdestregidx", i);
        addField(INST_FLTDESTREGSIDX, IDX_WIDTH,"fltdestregidx", i);
        addField(INST_PRVDESTREGSIDX, IDX_WIDTH,"prvdestregidx", i);
    }

    // Initialize storage for register file
    regFile.name = "registerfile";
    regFile.s = ST_REGFILE;

    for(int i =0; i < numRegs; ++i) {
        Field fd;

        fd.f = RF_REGISTER;
        fd.size = REGISTER_WIDTH;
        fd.regIdx = i;

        fd.reads = 0;
        fd.writes = 0;

        fd.name = "R" + std::string(std::to_string(i));

        regFile.fields.push_back(fd);

    }


    /* 
    fetchQueue.addField(INST_OPCODE, OPCODE_WIDTH);
    fetchQueue.addField(INST_PC, pcSize);
    fetchQueue.addField(INST_TID,1);
    fetchQueue.addField(INST_SEQNUM, SEQNUM_WIDTH);
    fetchQueue.addField(INST_PREDPC, pcSize);
    fetchQueue.addField(INST_FLAGS, FLAGS_WIDTH);
    fetchQueue.addField(INST_FAULT, FAULT_WIDTH);

    decodeQueue.addField(INST_OPCODE, OPCODE_WIDTH);
    decodeQueue.addField(INST_PC, pcSize);
    decodeQueue.addField(INST_TID, 1);
    decodeQueue.addField(INST_SEQNUM, SEQNUM_WIDTH);
    decodeQueue.addField(INST_PREDPC, pcSize);
    decodeQueue.addField(INST_FLAGS, FLAGS_WIDTH);
    decodeQueue.addField(INST_FAULT, FAULT_WIDTH);

    renameQueue.addField(INST_OPCODE, OPCODE_WIDTH);
    renameQueue.addField(INST_PC, pcSize);
    renameQueue.addField(INST_TID, 1);
    renameQueue.addField(INST_SEQNUM, SEQNUM_WIDTH);
    renameQueue.addField(INST_PREDPC, pcSize);
    renameQueue.addField(INST_FLAGS, FLAGS_WIDTH);
    renameQueue.addField(INST_FAULT, FAULT_WIDTH);

    iewQueue.addField(INST_OPCODE, OPCODE_WIDTH);
    iewQueue.addField(INST_PC, pcSize);
    iewQueue.addField(INST_TID, 1);
    iewQueue.addField(INST_SEQNUM, SEQNUM_WIDTH);
    iewQueue.addField(INST_PREDPC, pcSize);
    iewQueue.addField(INST_FLAGS, FLAGS_WIDTH);
    iewQueue.addField(INST_FAULT, FAULT_WIDTH);

    issueToExecQueue.addField(INST_OPCODE, OPCODE_WIDTH);
    issueToExecQueue.addField(INST_PC, pcSize);
    issueToExecQueue.addField(INST_TID, 1);
    issueToExecQueue.addField(INST_SEQNUM, SEQNUM_WIDTH);
    issueToExecQueue.addField(INST_PREDPC, pcSize);
    issueToExecQueue.addField(INST_FLAGS, FLAGS_WIDTH);
    issueToExecQueue.addField(INST_FAULT, FAULT_WIDTH);
    for(int i = 0; i < numDest; ++i) {

        fetchQueue.addRegField(INST_DESTREGSIDX, REGISTER_WIDTH, i);
        decodeQueue.addRegField(INST_DESTREGSIDX, REGISTER_WIDTH, i);
        renameQueue.addRegField(INST_DESTREGSIDX, REGISTER_WIDTH, i);
        iewQueue.addRegField(INST_DESTREGSIDX, REGISTER_WIDTH, i);
        issueToExecQueue.addRegField(INST_DESTREGSIDX, REGISTER_WIDTH, i);
    }
    for(int i = 0; i< numSrc; ++i) {

        fetchQueue.addRegField(INST_SRCREGSIDX, REGISTER_WIDTH, i);
        decodeQueue.addRegField(INST_SRCREGSIDX, REGISTER_WIDTH, i);
        renameQueue.addRegField(INST_SRCREGSIDX, REGISTER_WIDTH, i);
        iewQueue.addRegField(INST_SRCREGSIDX, REGISTER_WIDTH, i);

        issueToExecQueue.addRegField(INST_SRCREGSIDX, REGISTER_WIDTH, i);
    }
    */
}

/*
void
VulTracker::trackAccess(AccessType access, QueueType queue, InstField f) {
    
    switch(queue) {

        case FETCHQUEUE:

            fetchQueue.trackAccess(access, f);
            break;

        case DECODEQUEUE:

            decodeQueue.trackAccess(access, f);
            break;

        case RENAMEQUEUE:

            renameQueue.trackAccess(access, f);
            break;

        case IEWQUEUE:
            
            iewQueue.trackAccess(access, f);
            break;

        case ISSUETOEXECQUEUE:

            issueToExecQueue.trackAccess(access, f);
            break;

        default:

            break;
    }
}

void
VulTracker::trackRegAccess(AccessType access, QueueType queue, InstField f, int regIdx) {
    
    switch(queue) {

        case FETCHQUEUE:

            fetchQueue.trackRegAccess(access, f, regIdx);
            break;

        case DECODEQUEUE:

            decodeQueue.trackRegAccess(access, f, regIdx);
            break;

        case RENAMEQUEUE:

            renameQueue.trackRegAccess(access, f, regIdx);
            break;

        case IEWQUEUE:
            
            iewQueue.trackRegAccess(access, f, regIdx);
            break;

        case ISSUETOEXECQUEUE:

            issueToExecQueue.trackRegAccess(access, f, regIdx);
            break;

        default:

            break;
    }
}

void
VulTracker::markAsVulnerable(QueueType queue, InstField f, int regIdx) {

    bool isWritten = true;

    switch(queue) {

        case FETCHQUEUE:
            
            fetchQueue.markAsVulnerable(f, regIdx);
            break;

        case DECODEQUEUE:
            
            isWritten = decodeQueue.markAsVulnerable(f, regIdx);

            if(!isWritten)
                markAsVulnerable(FETCHQUEUE, f, regIdx);

            break;

        case RENAMEQUEUE:
            
            isWritten = renameQueue.markAsVulnerable(f, regIdx);

            if(!isWritten)
                markAsVulnerable(DECODEQUEUE, f, regIdx);

            break;

        case IEWQUEUE:

            isWritten = iewQueue.markAsVulnerable(f, regIdx);

            if(!isWritten)
                markAsVulnerable(RENAMEQUEUE, f, regIdx);

            break;

        case ISSUETOEXECQUEUE:

            isWritten = issueToExecQueue.markAsVulnerable(f, regIdx);

            if(!isWritten)
                markAsVulnerable(IEWQUEUE, f, regIdx);

            break;

        default:

            break;

    }

}

void
VulTracker::markAsWritten(QueueType queue, InstField f) {

    switch(queue) {

        case FETCHQUEUE:
            
            fetchQueue.markAsWritten(f);
            break;

        case DECODEQUEUE:
            
            decodeQueue.markAsWritten(f);
            break;

        case RENAMEQUEUE:
            
            renameQueue.markAsVulnerable(f);
            break;

        case IEWQUEUE:

            iewQueue.markAsVulnerable(f);
            break;

        case ISSUETOEXECQUEUE:

            issueToExecQueue.markAsVulnerable(f);
            break;

        default:

            break;

    }
}

long
VulTracker::getVul(QueueType queue) {
    
    long vul = 0;

    switch(queue) {

        case FETCHQUEUE:

            vul = fetchQueue.getVul();

            break;

        case DECODEQUEUE:

            vul = decodeQueue.getVul();

            break;

        case RENAMEQUEUE:

            vul = renameQueue.getVul();

            break;

        case IEWQUEUE:

            vul = iewQueue.getVul();

            break;

        case ISSUETOEXECQUEUE:

            vul = issueToExecQueue.getVul();

            break;

        default:

            break;

    }

    return vul;
}
*/

void
VulTracker::addField(InstField f, int size, std::string name, int idx) {

    Field fd;

    fd.f = f;
    fd.size = size;
    fd.regIdx = idx;
    fd.name = name;

    fd.reads = 0;
    fd.writes = 0;

    fields.push_back(fd);
}

void
VulTracker::vulOnRead(InstField f, int regIdx) {
    
    fIter fit = fields.begin();

    while(fit != fields.end()) {
        
        if(fit->f == f && regIdx == -1)
            break;
        else if(fit->f == f && regIdx == fit->regIdx)
            break;

        fit++;
    }
    assert(fit != fields.end());

    long vul = fit->size*(curTick() - fit->hist.t)/TICKS_PER_CYCLE;    
    fit->vul += vul;
    
    // If previous operation was a WRITE, then this READ is vulnerable.
    // If previous operation was a READ, then this READ is vulnerable.
    // If previous operation was INVALID, does not matter.
    if(fit->hist.op == WRITE || fit->hist.op == READ) {
        
        // Make a pair with the previous WRITE/READ tick and this READ,
        // which would then make a vulnerable interval.
        fit->vulIntervals.push_back(std::make_pair(fit->hist.t, curTick()));
    }


    fit->hist.op = READ;
    fit->hist.t = curTick();

    fit->reads++;

}

uStructure* 
VulTracker::selectStruct(uStruct s) {

    uStructure *st;

    switch(s) {

        case ST_REGFILE:
            st = &regFile;
            break;

        default:
            st = NULL;
            break;
    }

    return st;
}

void
VulTracker::vulOnRead(uStruct s, InstField f, int idx) {

    if(idx == 33)
        return;

    uStructure *st = selectStruct(s);

    assert(st != NULL);
    
    fIter fit = st->fields.begin();

    while(fit != st->fields.end()) {

        if(fit->f == f && idx == -1)
            break;
        else if(fit->f == f && idx == fit->regIdx)
            break;

        fit++;

    }

    assert(fit != st->fields.end());

    if(fit->hist.op == READ && fit->hist.t == curTick())
        return;
    
    fit->vul += fit->size*(curTick() - fit->hist.t)/TICKS_PER_CYCLE;

    if(fit->hist.op == WRITE || fit->hist.op == READ) {
        //DPRINTF(VulTracker,"Making pair %ld %ld\n",fit->hist.t,curTick());
        fit->vulIntervals.push_back(std::make_pair(fit->hist.t, curTick()));
    }

    fit->hist.op = READ;
    fit->hist.t = curTick();

    fit->reads++;
}


void
VulTracker::vulOnWrite(InstField f, int regIdx) {

    fIter fit = fields.begin();

    while(fit != fields.end()) {

        if(fit->f == f && regIdx == -1)
            break;
        else if(fit->f == f && regIdx == fit->regIdx)
            break;

        fit++;
    }
    assert(fit != fields.end());

    fit->hist.op = WRITE;
    fit->hist.t = curTick();
    fit->hist.incomingTick = curTick();        //Tick for the first write.

    fit->writes++;
}

void
VulTracker::vulOnWrite(uStruct s, InstField f, int idx) {

    if(idx == 33)
        return;

    uStructure *st = selectStruct(s);

    fIter fit = st->fields.begin();

    while(fit != st->fields.end()) {

        if(fit->f == f && idx == -1)
            break;
        else if(fit->f == f && idx == fit->regIdx)
            break;

        fit++;
    }

    assert(fit != st->fields.end());

    fit->hist.op = WRITE;
    fit->hist.t = curTick();
    fit->hist.incomingTick = curTick();

    fit->writes++;

}



bool 
VulTracker::isVulnerable(Tick t, InstField f, int regIdx) {
    
    if(t > curTick())
        return false;

    fIter fit = fields.begin();

    while(fit != fields.end()) {

        if(fit->f == f && regIdx == -1)
            break;
        else if(fit->f == f && regIdx == fit->regIdx)
            break;

        fit++;

    }

    assert(fit != fields.end());
    
    std::list<std::pair<long,long>>::iterator vulIt = fit->vulIntervals.begin();

    while( vulIt != fit->vulIntervals.end()) {

        if(t >= vulIt->first &&
                t <= vulIt->second) {
            return true;
        }

        vulIt++;
    }

    return false;
}

void
VulTracker::printVulIntervals(uStruct s, InstField f, int seqnum, int regIdx, bool isCommitted) {

    uStructure *st = selectStruct(s);

    fIter fit;

    if(st == NULL) {
        fit = fields.begin();

        while(fit != fields.end()) {

            if(fit->f == f && regIdx == -1)
                break;
            else if(fit->f == f && regIdx == fit->regIdx)
                break;

            fit++;
        }
        if(fit == fields.end())
            return;
    }
    else {
        fit = st->fields.begin();

        while(fit != st->fields.end()) {

            if(fit->f == f && regIdx == -1)
                break;
            else if(fit->f == f && regIdx == fit->regIdx)
                break;

            fit++;

        }
        if(fit == st->fields.end())
            return;
    }

    if(!isCommitted && fit->writes > 0)
        DPRINTF(VulTracker,"[sn:%i]: writes: %d reads: %d committed: %d\n", seqnum, fit->writes, fit->reads, (int)isCommitted); 
    std::list<std::pair<long,long>>::iterator vulIt = fit->vulIntervals.begin();

    while(vulIt != fit->vulIntervals.end()) {

        //DPRINTF(VulTracker,"[sn:%i]: %s vulnerable from tick %ld to %ld\n", seqnum, (fit->name).c_str(), 
        //                                                    vulIt->first, vulIt->second);
        vulIt++;

    }

}
